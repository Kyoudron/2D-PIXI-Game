<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="shortcut icon" href="%PUBLIC_URL%/favicon.ico">
    <!--
      Notice the use of %PUBLIC_URL% in the tag above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>My first three.js app</title>

    <style>
      body { margin: 0; }
      canvas { width: 100%; height: 100% }
    </style>

  </head>
  <body>
    <!-- <div id="root"></div> -->
    <script src="js/three.js"></script>
    <script src="js/pixi.min.js"></script>

    <script type="text/javascript">

      var Container = PIXI.Container,
          autoDetectRenderer = PIXI.autoDetectRenderer,
          loader = PIXI.loader,
          resources = PIXI.loader.resources,
          TextureCache = PIXI.utils.TextureCache,
          Texture = PIXI.Texture,
          Sprite = PIXI.Sprite,
          Graphics = PIXI.Graphics;
      //Create a Pixi stage and renderer and add the
      //renderer.view to the DOM
      var stage = new Container(),
          renderer = autoDetectRenderer(window.outerWidth, window.innerHeight);
      document.body.appendChild(renderer.view);
      loader
        .add("images/terraria/Ninja.png")
        .add("images/forest/dungeon2.png")
        .load(setup);
      //Define any variables that are used in more than one function
      var ninja, box, message, state;
      function setup() {
        //Create the box
        box = new PIXI.Graphics();
        box.beginFill(0xCCFF99);
        box.drawRect(0, 0, 64, 64);
        box.endFill();
        box.x = 120;
        box.y = 96;
        stage.addChild(box);

        //Create dungeon
        dungeon = new Sprite(resources["images/forest/dungeon2.png"].texture);
        dungeon.scale.set(2, 1)
        stage.addChild(dungeon)
        //Create the `ninja` sprite
        ninja = new Sprite(resources["images/terraria/Ninja.png"].texture);
        ninja.x = 16;
        ninja.y = 96;
        ninja.vx = 0;
        ninja.vy = 0;
        stage.addChild(ninja);
        //Capture the keyboard arrow keys
        var left = keyboard(37),
            up = keyboard(38),
            right = keyboard(39),
            down = keyboard(40);
        //Left arrow key `press` method
        left.press = function() {
          //Change the ninja's velocity when the key is pressed
          ninja.vx = -5;
          ninja.vy = 0;
        };
        //Left arrow key `release` method
        left.release = function() {
          //If the left arrow has been released, and the right arrow isn't down,
          //and the ninja isn't moving vertically:
          //Stop the ninja
          if (!right.isDown && ninja.vy === 0) {
            ninja.vx = 0;
          }
        };
        //Up
        up.press = function() {
          ninja.vy = -5;
          ninja.vx = 0;
        };
        up.release = function() {
          if (!down.isDown && ninja.vx === 0) {
            ninja.vy = 0;
          }
        };
        //Right
        right.press = function() {
          ninja.vx = 5;
          ninja.vy = 0;
        };
        right.release = function() {
          if (!left.isDown && ninja.vy === 0) {
            ninja.vx = 0;
          }
        };
        //Down
        down.press = function() {
          ninja.vy = 5;
          ninja.vx = 0;
        };
        down.release = function() {
          if (!up.isDown && ninja.vx === 0) {
            ninja.vy = 0;
          }
        };
        //Create the text sprite
        message = new PIXI.Text(
          "No collision...",
          {font: "18px sans-serif", fill: "white"}
        );
        message.position.set(8, 8);
        stage.addChild(message);
        //Set the game state
        state = play;

        //Start the game loop
        gameLoop();
      }
      function gameLoop(){
        //Loop this function 60 times per second
        requestAnimationFrame(gameLoop);
        //Update the current game state
        state();
        //Render the stage
        renderer.render(stage);
      }
      function play() {
        //use the ninja's velocity to make it move
        ninja.x += ninja.vx;
        ninja.y += ninja.vy;
        //check for a collision between the ninja and the box
        if (hitTestRectangle(ninja, box)) {
          //if there's a collision, change the message text
          //and tint the box red
          message.text = "hit!";
          box.tint = 0xff3300;
        } else {
          //if there's no collision, reset the message
          //text and the box's color
          message.text = "No collision...";
          box.tint = 0xccff99;
        }
      }
      //The `hitTestRectangle` function
      function hitTestRectangle(r1, r2) {
        //Define the variables we'll need to calculate
        var hit, combinedHalfWidths, combinedHalfHeights, vx, vy;
        //hit will determine whether there's a collision
        hit = false;
        //Find the center points of each sprite
        r1.centerX = r1.x + r1.width / 2;
        r1.centerY = r1.y + r1.height / 2;
        r2.centerX = r2.x + r2.width / 2;
        r2.centerY = r2.y + r2.height / 2;
        //Find the half-widths and half-heights of each sprite
        r1.halfWidth = r1.width / 2;
        r1.halfHeight = r1.height / 2;
        r2.halfWidth = r2.width / 2;
        r2.halfHeight = r2.height / 2;
        //Calculate the distance vector between the sprites
        vx = r1.centerX - r2.centerX;
        vy = r1.centerY - r2.centerY;
        //Figure out the combined half-widths and half-heights
        combinedHalfWidths = r1.halfWidth + r2.halfWidth;
        combinedHalfHeights = r1.halfHeight + r2.halfHeight;
        //Check for a collision on the x axis
        if (Math.abs(vx) < combinedHalfWidths) {
          //A collision might be occuring. Check for a collision on the y axis
          if (Math.abs(vy) < combinedHalfHeights) {
            //There's definitely a collision happening
            hit = true;
          } else {
            //There's no collision on the y axis
            hit = false;
          }
        } else {
          //There's no collision on the x axis
          hit = false;
        }
        //`hit` will be either `true` or `false`
        return hit;
      };
      //The `keyboard` helper function
      function keyboard(keyCode) {
        var key = {};
        key.code = keyCode;
        key.isDown = false;
        key.isUp = true;
        key.press = undefined;
        key.release = undefined;
        //The `downHandler`
        key.downHandler = function(event) {
          if (event.keyCode === key.code) {
            if (key.isUp && key.press) key.press();
            key.isDown = true;
            key.isUp = false;
          }
          event.preventDefault();
        };
        //The `upHandler`
        key.upHandler = function(event) {
          if (event.keyCode === key.code) {
            if (key.isDown && key.release) key.release();
            key.isDown = false;
            key.isUp = true;
          }
          event.preventDefault();
        };
        //Attach event listeners
        window.addEventListener(
          "keydown", key.downHandler.bind(key), false
        );
        window.addEventListener(
          "keyup", key.upHandler.bind(key), false
        );
        return key;
      }




    </script>
  </body>
</html>

